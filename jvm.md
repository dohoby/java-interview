# java虚拟机知识
## java内存模型
![jvm内存模型](images/jvm-memory.png)
如果线程请求的栈深度大于虚拟机所允许 的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动 态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存， 就会抛出OutOfMemoryError异常。
### 程序计数器
一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分 支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成,没有oom溢出
### Java虚拟机栈
线程私有的，它的生命周期与 线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 （Stack Frame [1] ）用于存储局部变量表、操作数栈、动态链接、方法出口等信息
### 本地方法栈
本地方法栈则为虚拟机使用到的Native方法服务，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常
### java堆
分为新生代和永久代，再细分Eden，From survivor，To Survivor
### 方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。
## java的内存溢出类型
堆内存溢出
虚拟机栈内存溢出


## jvm垃圾回收器
* Serial收集器，新生代收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须 暂停其他所有的工作线程，直到它收集结束
* ParNew收集器，新生代收集器，其实就是Serial收集器的多线程版本,
* Parallel Scavenge,新生代收集器,收集器的目标则是达到一个可控制的吞吐量
* Serial Old是Serial收集器的老年代版本，是一个单线程收集器，使用“标记-整理”算法
* Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法
* cms收集器是基于“标记—清除”算法实现的
* G1，分代收集，G1从整体来看是基于“标记—整理”算法实现的收集 器，从局部（两个Region之间）上来看是基于“复制”算法实现的*
## jvm垃圾回收算法
* 复制算法，效率高，但是空间利用不足
* 标记整理，不会产生空间碎片
* 标记清除，产生大量空间碎片，不利于大对象的内存分配
## jvm参数

## jvm类加载机制

## jvm线上问题分析工具
### jdk自带的工具


